useQuery를 동적으로 사용하는 방법은,
queryKey 배열을 동적인 값을 넣어주고, 해당 값이 변경될 때 마다 fetch 함수를 실행시킨다.
queryFn 프로퍼티의 fetch 함수의 포인터만 찍어주는게 아니라 fetch 함수를 실행하는 익명 함수로 만들어서
인자를 넘겨주는 방식으로 사용할 수 있다.

이때 queryFn에서 기본적으로 제공되는 객체가 있는데 인자를 넘겨줄 때 이점에 주의해야한다.
이 객체 안에는 queryKey, meta, signal 프로퍼티가 존재하는데,
signal 프로퍼티는 해당 http 요청을 취소했을 때(예를 들어 사용자가 브라우저를 종료했을 때) 사용한다.

ex)
const fetchSome = async ({ someText, signal }) => {
    let url = 'http://localhost:8080';

    if(someText) {
        url += '?some=' + someText
    }

    const response = await fetch(url, { signal })

    if(!response.ok) {
        const error = new Error('Some Error');
        error.code = response.status;
        error.info = await response.json();
        throw error
    }

    const { someData } = await response.json();

    return someData
}

const SomeComponent = () => {
    const [someText,setSomeText] = useState('');
    
    const { data, isPending, isError, error } = useQuery({
        queryKey: ['some', someText],
        queryFn: ({ signal }) => fetchSome({ signal, someText })
    })

    return (
        <div>
            <input onChange={(e) => setSomeText(e.target.value)} value={someText}>
        </div>
    )
}

======================================================================

특정한 상황에서 useQuery를 비활성화 하고 싶을때에는 useQuery 인자로 들어가는 객체의
enabled 프로퍼티를 사용하면 된다.
해당 프로퍼티의 값이 true일 때에는 활성화, false일 때에는 비활성화 되어서 queryFn의 fetch 요청을 하지 않는다.

이때 useQuery에서 반환하는 값 중 isPending을 사용해서 UI를 변경시키고 있다면
isPending 대신 isLoading으로 바꿔주는것이 좋다

isPending과 isLoading의 차이점은 
isPending은 쿼리가 비활성중일때에도 true를 반환하지만, isLoading은 쿼리가 로딩중일때에만 true를 반환한다.

ex)
const SomeComponent = () => {
    const [flag,setFlag] = useState(false);

    const { data, isLoading, error } = useQuery({
        queryKey: ['some'],
        queryFn: func,
        enabled: flag,
    })

    const toggleHandler = () => {
        setFlag(prevFlag => !prevFlag)
    }

    return (
        <button onClick={toggleHandler}>Toggle</button>
    )
}